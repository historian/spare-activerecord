
module Snapshots
  class DatabaseDumper < ActiveRecord::SchemaDumper
    
    def dump(stream)
      super(stream)
      tables_for_data(stream)
      stream
    end
    
    def header(stream)
      stream.puts <<-EOC
# This file was generated by the Snapshots::DatabaseDumper and
# can be loaded with the Snapshots::DatabaseLoader.

ActiveRecord::Schema.define do

  create_table "schema_migrations", :id => false, :force => true do |t|
    t.string "version", :null => false
  end

  add_index "schema_migrations", ["version"], :name => "unique_schema_migrations", :unique => true

EOC
    end
    
  private
    
    def tables_for_data(stream)
      stream.puts "\nSnapshots::DatabaseLoader.load do\n\n"
      @connection.tables.sort.each do |tbl|
        next if [ignore_tables].flatten.any? do |ignored|
          case ignored
          when String; tbl == ignored
          when Regexp; tbl =~ ignored
          else
            raise StandardError, 'ActiveRecord::SchemaDumper.ignore_tables accepts an array of String and / or Regexp values.'
          end
        end 
        table_for_data(tbl, stream)
      end
      stream.puts "end\n"
    end
    
    def table_for_data(table, stream)
      columns = @connection.columns(table)
      
      column_names = columns.collect { |column| "#{table}.#{column.name}" }
      
      rows = @connection.select_rows("SELECT #{column_names.join(', ')} FROM #{table}")
      
      stream.puts "  for_table #{table.inspect} do |t|"
      rows.each do |row|
        stream.print "    t.insert(\n"
        columns.each_with_index do |column, idx|
          cell = column.type_cast(row[idx])
          cell = case cell
          when DateTime then "#{cell.to_formatted_s(:rfc822).inspect}.to_datetime"
          when Date     then "#{cell.to_formatted_s(:rfc822).inspect}.to_date"
          when Time     then "#{cell.to_formatted_s(:rfc822).inspect}.to_time"
          else cell.inspect
          end
          stream.print "      :#{column.name} => #{cell}"
          stream.print ',' unless idx == (columns.size - 1)
          stream.print "\n"
        end
        stream.print "    )\n"
        stream.flush
      end
      stream.puts "  end\n\n"
    end
    
  end
end
